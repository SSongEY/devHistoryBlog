{"componentChunkName":"component---src-templates-post-template-jsx","path":"/history/posts/2020-11-10--003","result":{"data":{"site":{"siteMetadata":{"title":"Blog by Eunyoung","subtitle":"EY's 개발 히스토리 블로그","copyright":"© All rights reserved.","author":{"name":"EunYoung","twitter":"#"},"disqusShortname":"","url":"https://eunyoung-autocrypt.github.io"}},"markdownRemark":{"id":"d01df248-ca57-5a37-a968-92e06076e651","html":"<h2>DTO Class Code Convention</h2>\n<p><img src=\"./001.PNG\"></p>\n<h3>#1.클래스 정의 방법</h3>\n<ul>\n<li>도메인 또는 리소스 별 DTO 클래스 생성 후(CouponDto), 각 API(Controller 에 정의된 메소드: CreateReq, CreateRes) 에 해당하는 DTO를 InnerClass 로 정의</li>\n<li>CouponDto의 객체 생성을 하지 않으므로 InnerClass는 static 키워드를 명시한다.</li>\n</ul>\n<br>\n<h3>#2.생성자의 접근자는 최소한으로</h3>\n<ul>\n<li>객체 생성이 불필요한 클래스의 기본 생성자 접근자는 Private로 지정<br>\n—> 개별 DTO는 InnerClass로 정의하기 때문에 객체 생성이 불필요하다.  </li>\n</ul>\n<p><img src=\"./002.PNG\"></p>\n<br>\n<h3>#3. Request Dto 클래스</h3>\n<p><img src=\"./003.PNG\"></p>\n<h4>##3-1. @NoArgsConstructor 의 접근자는 Private로 한다.</h4>\n<ul>\n<li>@RequestBody 를 사용하면 Spring 내부에서 Jackson 라이브러리를 사용하여 Deserialize (JSON 데이터와 Request 객체 사이의 변환) 을 한다.</li>\n<li>이때 기본 전략으로 Default Constructor + Reflection 을 사용한다. 이때 최소 접근자는 Private 이다.\n<img src=\"./004.PNG\"></li>\n</ul>\n<h4>##3-2. Data Validation</h4>\n<ul>\n<li>Bean Validation에서 제공하는 @NotNull, @NotBlank, @Pattern 등을 사용하여 Request Data에 대한 오류를 최소화 한다.</li>\n<li>꼭 @RequestBody 옆에 @Valid 를 명시해줘야 한다.<br>\n<img src=\"./005.PNG\">  </li>\n<li>Validation이 실패할 경우, MethodArgumentNotValidException 의 예외가 발생한다.\n<img src=\"./007.PNG\"></li>\n</ul>\n<br>\n<h3>#4. Response Dto 클래스</h3>\n<p><img src=\"./008.PNG\"></p>\n<h4>##4-1. 객체 생성을 위해 필드가 3개 이상일 경우는 @Builder를 사용한다.</h4>\n<ul>\n<li>@Builder 사용 시 All Arguments Constructor 가 자동으로 생성된다.  </li>\n<li>생성자를 이용한 객체 생성을 막기 위해 생성자를 따로 정의한 후(@AllArgsConstructor) 접근제어자를 Private로 정의한다.<br>\n<img src=\"./009.PNG\"></li>\n</ul>\n<h4>##4-2. 객체 생성을 위해 필드가 3개 이상일 경우는 @Builder를 사용한다.</h4>\n<h4>##4-3. @Getter 필요 이유</h4>\n<ul>\n<li>@ResponseBody 를 사용하면 Spring 내부에서 Jackson 라이브러리를 사용하여 Response 객체를 Serialize(ByteCode로 변환) 하는데 이때 getter 메소드를 사용한다.  </li>\n<li>따라서 response 객체는 @Getter 를 사용해야 한다.</li>\n</ul>\n<br>\n<hr>\n<br>\n<h2>MapStruct</h2>\n<ul>\n<li>DTO -> Entity, Entity -> DTO의 객체 매핑을 위한 라이브러리</li>\n</ul>\n<h3>#1. gradle 추가</h3>\n<ul>\n<li>롬복과 함께 사용 시, lombok annotationProcessor 보다 mapstruct annotationProcessor가 먼저 선언이 되야 한다.</li>\n<li>SpringBoot 버전에 호환하는 MapStruct 버전이 존재, 해당부분 확인 필요\n<img src=\"./010.PNG\"></li>\n</ul>\n<br>\n<h3>#2. Mapper Interface 생성</h3>\n<p><img src=\"./011.PNG\"></p>\n<h4>##2-1. @Mapper 사용</h4>\n<ul>\n<li>매핑 정책(Policy)과 전략(Strategy)를 설정할 수 있다.  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>정책</th>\n<th>값</th>\n<th>설명</th>\n<th>예시</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>unmappedSourcePolicy</td>\n<td>IGNORE(default), WARN, ERROR</td>\n<td>Source의 필드가 Target에 매핑되지 않을 때 정책이다.</td>\n<td>ERROR로 설정하면 매핑 시 Source.aField가 사용되지 않는다면 컴파일 오류가 발생시킨다.</td>\n</tr>\n<tr>\n<td>unmappedTargetPolicy</td>\n<td>IGNORE, WARN(default), ERROR</td>\n<td>Target의 필드가 매핑되지 않을 때 정책이다.</td>\n<td>ERROR로 설정하면 매핑 시 Target.aField에 값이 매핑되지 않는다면 컴파일 오류가 발생시킨다.</td>\n</tr>\n<tr>\n<td>typeConversionPolicy</td>\n<td>IGNORE(default), WARN, ERROR</td>\n<td>타입 변환 시 유실이 발생할 수 있을 때 정책이다.</td>\n<td>ERROR로 설정하면 long에서 int로 값을 넘길 때 값에 유실이 발생할 수 있다. 이런 경우에 컴파일 오류를 발생시킨다.</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>전략</th>\n<th>값</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nullValueMappingStrategy</td>\n<td>RETURN<em>NULL(default), RETURN</em>DEFAULT</td>\n<td>Source가 null일 때 정책이다.</td>\n</tr>\n<tr>\n<td>nullValuePropertyMappingStrategy</td>\n<td>SET<em>TO</em>NULL(default), SET<em>TO</em>DEFAULT, IGNORE</td>\n<td>Source의 필드가 null일 때 정책이다.</td>\n</tr>\n</tbody>\n</table>\n<h4>##2-2. INSTANCE 생성</h4>\n<ul>\n<li>빌드 시점에 CouponMapper 를 상속받은 CouponMapperImpl(구현체) 클래스가 생성된다.</li>\n<li>따라서 이 구현체를 사용할 수 있는 객체를 생성한다.</li>\n</ul>\n<br>\n<h3>#3. Mapper 사용</h3>\n<h4>#3-1. Dto to Entity 또는 Entity to Dto 선언부 생성</h4>\n<p><img src=\"./012.PNG\"></p>\n<h4>#3-2. @Getter, @Builder 설정</h4>\n<ul>\n<li>변환과정에서 꺼내오는 객체(source)에는 Getter가 있어야 하고, 변환해서 저장하고자 하는 객체(target)에는 Builder 혹은 Setter가 있어야 하는데 Setter는 지양한다.<br>\n<img src=\"./013.PNG\">\n<img src=\"./014.PNG\">\n<img src=\"./015.PNG\"></li>\n</ul>\n<br>\n<h5>201203 수정사항</h5>\n<ul>\n<li>Dto 클래스 내 Mapper 호출 메소드 명 변경<br>\n—> createReqToEntity() -> toEntity()<br>\n—> entityToCreateRes() -> of()  </li>\n<li>Response Dto 클래스 내 Validation 제거<br>\n— res Dto 클래스 serialize 전 validation 로직 없음  </li>\n<li>MethodArgumentNotValidException 이미지 추가</li>\n</ul>","fields":{"tagSlugs":["/tags/dto/"],"slug":"/history/posts/2020-11-10--003"},"frontmatter":{"title":"[Code Convention] DTO Class","tags":["dto"],"date":"2020-11-10","description":""}}},"pageContext":{"slug":"/history/posts/2020-11-10--003"}},"staticQueryHashes":[]}